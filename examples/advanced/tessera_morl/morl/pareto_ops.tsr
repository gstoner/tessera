package morl

@kernel pareto_filter(points: tensor<NxMxf32>, out_mask: tensor<Nxi1>) tile[TM=128] {
  smem p_tile: f32[TM, M]
  smem q_tile: f32[TM, M]
  smem dominated: i1[TM]

  for base in range(0, N, TM) {
    load p_tile from points[base:base+TM, :]
    fill dominated[:] = 0

    for other in range(0, N, TM) {
      load q_tile from points[other:other+TM, :]
      barrier()

      parallel_for i in 0..TM {
        if (base+i >= N) continue
        if (dominated[i]) continue
        for j in 0..TM {
          if (other+j >= N) break
          all_ge = true; any_gt = false
          for m in 0..M {
            all_ge &= (q_tile[j,m] >= p_tile[i,m])
            any_gt |= (q_tile[j,m] >  p_tile[i,m])
          }
          if (all_ge & any_gt) { dominated[i] = 1; break }
        }
      }
      barrier()
    }

    store out_mask[base:base+TM] = not dominated[:]
  }
}
