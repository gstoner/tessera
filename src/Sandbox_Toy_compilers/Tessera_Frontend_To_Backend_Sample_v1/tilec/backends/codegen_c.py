import os, pathlib, textwrap
from ..ir import IRModule

DEFAULT_M = 128
DEFAULT_N = 128
DEFAULT_K = 128

def emit(ir: IRModule, out_dir: str, exe_name: str = "a.out"):
    out = pathlib.Path(out_dir)
    out.mkdir(parents=True, exist_ok=True)

    f = ir.funcs[0]
    kernel_params = ", ".join(["float* "+p for p in f.params] + ["int M", "int N", "int K"])

    kernel_body_parts = []
    temps_declared = set()

    for op in f.body:
        if op["op"] == "matmul":
            outv, lhs, rhs = op["out"], op["lhs"], op["rhs"]
            kernel_body_parts.append(textwrap.dedent(f'''
                // {outv} = {lhs} @ {rhs}  (MxK) x (KxN) = (MxN)
                for (int i = 0; i < M; ++i) {{
                  for (int j = 0; j < N; ++j) {{
                    float acc = 0.0f;
                    for (int k = 0; k < K; ++k) {{
                      acc += {lhs}[i*K + k] * {rhs}[k*N + j];
                    }}
                    {outv}[i*N + j] = acc;
                  }}
                }}
            ''').strip())
        elif op["op"] == "add":
            outv, lhs, rhs = op["out"], op["lhs"], op["rhs"]
            kernel_body_parts.append(textwrap.dedent(f'''
                // {outv} = {lhs} + {rhs}  (elementwise MxN)
                for (int i = 0; i < M; ++i) {{
                  for (int j = 0; j < N; ++j) {{
                    {outv}[i*N + j] = {lhs}[i*N + j] + {rhs}[i*N + j];
                  }}
                }}
            ''').strip())

    kernel_body = "\\n\\n            ".join(kernel_body_parts)

    kernel_src = textwrap.dedent(f'''
        // Auto-generated by tilec C backend
        #include <stdio.h>
        #include <stdlib.h>
        #include <math.h>
        #include <time.h>

        void kernel_{f.name}({kernel_params}) {{
            {kernel_body}
        }}

        static inline float frand() {{ return (float)rand() / (float)RAND_MAX; }}

        int main(int argc, char** argv) {{
          // Shapes from env or defaults
          int M = getenv("M") ? atoi(getenv("M")) : {DEFAULT_M};
          int N = getenv("N") ? atoi(getenv("N")) : {DEFAULT_N};
          int K = getenv("K") ? atoi(getenv("K")) : {DEFAULT_K};

          size_t szA = (size_t)M*K, szB = (size_t)K*N, szC = (size_t)M*N;

          float* A = (float*)aligned_alloc(64, szA * sizeof(float));
          float* B = (float*)aligned_alloc(64, szB * sizeof(float));
          float* C = (float*)aligned_alloc(64, szC * sizeof(float));
          float* T = (float*)aligned_alloc(64, szC * sizeof(float)); // scratch

          if(!A||!B||!C||!T) {{ fprintf(stderr, "alloc failed\\n"); return 2; }}
          srand(0xC0FFEE);

          for (size_t i=0;i<szA;++i) A[i] = frand();
          for (size_t i=0;i<szB;++i) B[i] = frand();
          for (size_t i=0;i<szC;++i) {{ C[i] = 0.0f; T[i] = 0.0f; }}

          // Demo mapping: first param -> A, second -> B, third -> C/bias if present
          {"// Params: " + ", ".join(f.params)}
          {"float* " + (f.params[0] if len(f.params)>0 else "P0") + " = A;"}
          {"float* " + (f.params[1] if len(f.params)>1 else "P1") + " = B;"}
          {"float* " + (f.params[2] if len(f.params)>2 else "P2") + " = C;"}

          // Call kernel (pass declared buffers followed by dims)
          kernel_{f.name}({", ".join((f.params + ["M","N","K"]))});

          // checksum
          double sum = 0.0;
          for (size_t i=0;i<szC;++i) sum += C[i];
          printf("OK  M=%d N=%d K=%d  checksum=%.6f\\n", M,N,K, sum);

          free(A); free(B); free(C); free(T);
          return 0;
        }}
    ''').strip() + "\\n"

    (out / f"{f.name}.c").write_text(kernel_src)

    makefile = textwrap.dedent(f'''
        CC ?= cc
        CFLAGS ?= -O3 -march=native -std=c11

        all: {f.name}

        {f.name}: {f.name}.c
        	$(CC) $(CFLAGS) -o {f.name} {f.name}.c

        clean:
        	rm -f {f.name}
    ''').strip() + "\\n"
    (out / "Makefile").write_text(makefile)

    return str(out / f"{f.name}.c")
