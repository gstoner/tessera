#include "tessera/targets/cerebras/Passes.h"
#if HAVE_MLIR
#include "mlir/IR/BuiltinOps.h"
#include "mlir/Pass/Pass.h"
#include "mlir/IR/Visitors.h"
#include "mlir/Support/FileUtilities.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Path.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/SmallVector.h"
#include <system_error>
#include <string>

#include "CerebrasDialect.h.inc"
#include "CerebrasOps.h.inc"

using namespace mlir;

namespace {

static void emitRegionBodyToCSL(Operation *container, llvm::raw_ostream &CO) {
  // Walk direct children (flat) to serialize interesting ops.
  for (Operation &op : *container->getRegion(0).begin()) {
    if (auto ld = dyn_cast<tessera::cerebras::LoadSRAMOp>(&op)) {
      CO << "  load_sram ...    // implies memcpy(sram,global)\n";
      CO << "  memcpy(sram,global)\n";
    } else if (auto st = dyn_cast<tessera::cerebras::StoreSRAMOp>(&op)) {
      CO << "  store_sram ...   // implies memcpy(global,sram)\n";
      CO << "  memcpy(global,sram)\n";
    } else if (auto cp = dyn_cast<tessera::cerebras::MemcpyOp>(&op)) {
      CO << "  memcpy(" << cp.getDst_space().str() << "," << cp.getSrc_space().str() << ")\n";
    } else if (auto mm = dyn_cast<tessera::cerebras::MatmulOp>(&op)) {
      CO << "  matmul(" << (int)mm.getM() << "," << (int)mm.getN() << "," << (int)mm.getK() << ")\n";
    }
  }
}

struct CSLEmit : public PassWrapper<CSLEmit, OperationPass<ModuleOp>> {
  void runOnOperation() override {
    ModuleOp mod = getOperation();
    // Default outputs; overridable via cerebras.emit
    std::string cslOut = "out.csl";
    std::string layoutOut = "layout.json";
    mod.walk([&](tessera::cerebras::EmitOp e) {
      cslOut = e.getCsl_out().str();
      layoutOut = e.getLayout_out().str();
    });

    // Gather layout data
    struct RegionInfo { int x0,y0,x1,y1,color; Operation *op; };
    struct RouteInfo { int from,to,color; };
    SmallVector<RegionInfo, 16> regions;
    SmallVector<RouteInfo, 16> routes;

    mod.walk([&](tessera::cerebras::RegionOp r) {
      regions.push_back({ (int)r.getX0(), (int)r.getY0(), (int)r.getX1(), (int)r.getY1(), (int)r.getColor(), r.getOperation() });
    });
    mod.walk([&](tessera::cerebras::RouteOp r) {
      routes.push_back({ (int)r.getFrom(), (int)r.getTo(), (int)r.getColor() });
    });

    // Write layout JSON
    std::error_code ec;
    std::unique_ptr<llvm::ToolOutputFile> layoutFile = mlir::openOutputFile(layoutOut, ec);
    if (ec) {
      llvm::errs() << "Failed to open layout file: " << layoutOut << " : " << ec.message() << "\n";
      signalPassFailure();
      return;
    }
    auto &LO = layoutFile->os();
    LO << "{\n  \"regions\": [\n";
    for (size_t i=0;i<regions.size();++i) {
      auto &r = regions[i];
      LO << "    {\"x0\":"<<r.x0<<",\"y0\":"<<r.y0<<",\"x1\":"<<r.x1<<",\"y1\":"<<r.y1<<",\"color\":"<<r.color<<"}";
      LO << (i+1<regions.size()? ",\n" : "\n");
    }
    LO << "  ],\n  \"routes\": [\n";
    for (size_t i=0;i<routes.size();++i) {
      auto &r = routes[i];
      LO << "    {\"from\":"<<r.from<<",\"to\":"<<r.to<<",\"color\":"<<r.color<<"}";
      LO << (i+1<routes.size()? ",\n" : "\n");
    }
    LO << "  ]\n}\n";
    layoutFile->keep();

    // Write richer CSL grouped by region
    std::unique_ptr<llvm::ToolOutputFile> cslFile = mlir::openOutputFile(cslOut, ec);
    if (ec) {
      llvm::errs() << "Failed to open CSL file: " << cslOut << " : " << ec.message() << "\n";
      signalPassFailure();
      return;
    }
    auto &CO = cslFile->os();
    CO << "// Rich CSL (scaffold) generated by CSLEmit\n";
    for (auto &r : regions) {
      CO << "region {"<<r.x0<<","<<r.y0<<","<<r.x1<<","<<r.y1<<","<<r.color<<"} {\n";
      emitRegionBodyToCSL(r.op, CO);
      CO << "}\n";
    }
    cslFile->keep();

    // Print a line for FileCheck
    llvm::outs() << "CSL-EMIT: wrote " << cslOut << " and " << layoutOut << "\n";
  }
};

} // namespace

namespace tessera { namespace cerebras {
std::unique_ptr<mlir::Pass> createCerebrasCSLEmitPass() {
  return std::make_unique<CSLEmit>();
}
}} // namespace

#else
// No-MLIR build
#endif
